[
  {
    "title": "Introduction",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-programming-intro/",
    "content": "C++ is a general-purpose programming language that was developed by Bjarne Stroustrup as an enhancement of the C language to add object-oriented paradigm. The main features C++ programming language are as follows:\nSimple\n: It is a simple language in the sense that programs can be broken down into logical units and parts, and has a rich library support and a variety of datatypes.\nMachine Independent\n: C++ code can be run on any machine as long as a suitable compiler is provided.\nLow-level Access:\nC++ provides low-level access to system resources, which makes it a suitable choice for system programming and writing efficient code.\nFast Execution Speed\n: C++ is one of the fastest high-level languages. There is no additional processing overhead in C++, it is blazing fast.\nObject-Oriented\n: One of the strongest points of the language which sets it apart from C. Object-Oriented support helps C++ to make maintainable and extensible programs. i.e. large-scale applications can be built.\nFirst C++ Program\nThe below C++ code shows the basic structure of a program. Learn more about how it works in this\narticle\n.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\ncout\n<<\n\"Hello, World!\"\n;\nreturn\n0\n;\n}\nOutput\nHello, World!\nStructure of the C++ program\nThe basic structure of a C++ program defines the standard way every program must be written; otherwise, it will cause a compilation error. The structure includes:\nHeader File:\n#include <iostream> adds input/output objects (cin, cout, etc.) via the preprocessor. Common headers: fstream (files), string (strings), vector (STL), bits/stdc++.h (all-in-one).\nNamespace Declaration:\nusing namespace std; allows direct use of standard names like \"cout\" without std::\nMain Function:\nint main() is the program’s entry point; execution starts here and returns an integer with 0 return mean successful execution.\nComments:\n// for single line, /*....*/ for multi-line are ignored by the compiler and used only for code documentation.\nStatement:\nContains executable code. Here, cout << \"Hello World!\", prints the text on the screen using the insertion operator (<<).\nReturn:\nThe return 0; statement terminates the main() function and indicates that the program executed successfully.\nHistory of C++\nC++ is an object-oriented,\nmiddle-level\nprogramming language developed by Bjarne Stroustrup at Bell Labs in 1979, originally called “\nC with Classes\n” and renamed to C++ in 1983. It extended C by adding features like classes, inheritance, and type checking to support\nobject-oriented programming\n. Over time, it evolved through standards like C++98, C++11, C++17, C++20, and the latest C++23, adding modern features for performance and safety. Today, C++ remains widely used in system software, game engines, competitive programming, and high-performance applications.\nImportant Links:\nC++ vs Other Languages\nCreate Quiz\nIntroduction to C++\nVisit Course\nComment\nC\nchinmoy lenka\nFollow\n974\nImprove\nC\nchinmoy lenka\nFollow\n974\nImprove\nArticle Tags :\nC++\nCPP-Basics",
    "content_length": 3014,
    "scraped_at": "2025-12-07 16:23:41",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Identifiers",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-identifiers/",
    "content": "In C++ programming language,\nidentifiers\nare the unique names assigned to variables, functions, classes, structs, or other entities within the program. Let's take a look at an example:\nC++\n// Creating a variable\nint\nval\n=\n10\n;\n// Creating a function\nvoid\nfunc\n()\n{}\nIn the above code, the words\nval\nand\nfunc\nare identifiers. Basically, everything named by a programmer is an identifier and is used to refer to the entity later in the program.\nRules for Naming an Identifier\nWe can use any word as an identifier as long as it follows the following rules:\nAn identifier can consist of\nletters\n(A-Z or a-z),\ndigits\n(0-9), and\nunderscores (_)\n. Special characters and spaces are not allowed.\nAn identifier can only begin with a\nletter or an underscore only.\nC++ has reserved\nkeywords\nthat cannot be used as identifiers since they have predefined meanings in the language. For example,\nint\ncannot be used as an identifier as it already has some predefined meaning in C++. Attempting to use these as identifiers will result in a compilation error.\nIdentifier must be\nunique\nin its namespace.\nAdditionally, C++ is a case-sensitive language so the identifier such as\nNum\nand\nnum\nare treated as different. The below images show some valid and invalid C++ identifiers.\nTo know more about identifiers naming rules, refer to this article –\nNaming Convention in C++\nExample of Valid/Invalid Identifiers\nExample\nIn this example, we have used the identifiers by following the guidelines and we use identifiers to name a\nclass\n, function, integer data type, etc. If you are not aware of\nfunctions\nand\nclasses\nin C++ then don’t worry, you will learn them soon. The below code is run successfully which means we named them correctly.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Here Car identifier is used to refer to below class\nclass\nCar\n{\nstring\nBrand\n;\nstring\nmodel\n;\nint\nyear\n;\n};\n// getSum identifier is used to call the below\n// function\nvoid\ngetSum\n(\nint\na\n,\nint\nb\n)\n{\nint\n_sum\n=\na\n+\nb\n;\ncout\n<<\n\"The sum is: \"\n<<\n_sum\n;\n}\nint\nmain\n()\n{\n// Identifiers used as variable names\nint\nstudentAge\n=\n20\n;\ndouble\naccountBalance\n=\n1000.50\n;\nstring\nstudent_Name\n=\n\"Karan\"\n;\ngetSum\n(\n2\n,\n10\n);\nreturn\n0\n;\n}\nOutput\nThe sum is: 12\nIdentifier Naming Conventions\nNaming conventions\nare not the rules enforced by C++ language but are suggestions for naming variables by the programming community for easier understanding. Some of the naming conventions are as follows:\nFor Variables:\nUse camelCase (for constants, you can use UPPER_SNAKE_CASE)\nStart with lowercase alphabet.\nUse descriptive, meaningful names.\nFor example, frequencyCount, personName\nFor Functions:\nUse camelCase.\nUse Verb or verb phrases for naming.\nFor example, getName(), countFrequency(), etc\n.\nFor Classes:\nUse PascalCase\nUse Nouns or noun phrases for naming.\nFor example, Car, Person, etc\nOnce again, above are some suggestions for naming identifiers do not rule. They also depend on the project guidelines you are working on and your preferences.\nCreate Quiz\nComment\nS\nsagar99\nFollow\n22\nImprove\nS\nsagar99\nFollow\n22\nImprove\nArticle Tags :\nC++\nCPP-Basics",
    "content_length": 3103,
    "scraped_at": "2025-12-07 16:23:43",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Keywords",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-keywords/",
    "content": "Keywords are the reserved words that have special meanings. Since their meanings are reserved, we cannot redefine them or use them for a different purpose.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// 'int' is a keyword\nint\nmain\n()\n{\n// 'int' is a keyword\nint\nage\n=\n20\n;\n// 'if' is a keyword\nif\n(\nage\n>\n18\n)\n{\ncout\n<<\n\"Adult\"\n;\n}\n// 'return' is a keyword\nreturn\n0\n;\n}\nOutput\nAdult\nHow to Identify C++ Keywords\nSyntax Highlighting\n: Most modern IDEs (like Visual Studio, CLion, Code::Blocks) highlight keywords in a different color. This makes them stand out from variables or function names.\nCompiler Errors\n: If you mistakenly use a keyword as a variable name, your code won’t compile.\nExample:\nC++\nint\nreturn\n=\n10\n;\n// Error: 'return' is reserved\nCategorization of C++ Keywords\nTo make them easier to understand, let’s group C++ keywords by context:\nCategory\nKeywords\nData Types\nbool\n,\nchar\n,\nchar8_t\n, char16_t, char32_t, int, long, short, signed, unsigned, float, double, void, wchar_t\nControl Flow\nif\n,\nelse\n,\nswitch\n, case,\ndefault\n,\nfor\n,\nwhile\n,\ndo\n,\nbreak\n,\ncontinue\n,\ngoto\nBoolean & Null\ntrue, false,\nnullptr\nMemory Management\nnew,\ndelete\n,\nsizeof\n,\nalignas\n,\nalignof\nClasses & Structs\nclass,\nstruct\n,\nunion\n,\nenum\n,\nfriend\n,\nmutable\n,\nthis\nAccess Specifiers\npublic\n,\nprivate\n,\nprotected\nFunctions & Modifiers\ninline\n,\nexplicit\n,\nvirtual\n, override,\nfinal\n,\nconstexpr\n, consteval,\nconstinit\n, operator,\ntypedef\n, using,\ntypename\nTemplates & Generics\ntemplate\n, concept, requires\nException Handling\ntry\n,\ncatch\n, throw,\nnoexcept\nCasting & Type Info\nconst_cast\n,\ndynamic_cast\n,\nreinterpret_cast\n,\nstatic_cast\n,\ndecltype\n,\ntypeid\nConstants & Storage\nconst\n,\nstatic\n,\nstatic_assert\n,\nextern\n, register,\nthread_local\n,\nvolatile\nModules / Export\nexport,\nnamespace\nCoroutines (C++20)\nco_await, co_return, co_yield\nOperators (alt spellings)\nand, and_eq, or, or_eq, not, not_eq, bitand, bitor, compl, xor, xor_eq\nMiscellaneous\nasm\n,\nauto\n,\nreturn\n,\nsizeof\nNote\n: The number of keywords C++ has evolved over time as new features were added to the language.\nFor example\n, C++ 98 had 63 keywords, C++ 11 had 84 keywords, C++.\nKeywords vs Identifiers\nSo, there are some properties of keywords that\ndistinguish keywords from identifiers.\nThey listed in the below table\nKeywords\nIdentifiers\nKeywords are predefined/reserved words\nidentifiers are the values used to define different programming items like a variable, integers, structures, and unions.\nIt defines the type of entity.\nIt classifies the name of the entity.\nA keyword contains only alphabetical characters,\nan identifier can consist of alphabetical characters, digits, and underscores.\nIt should be lowercase.\nIt can be both upper and lowercase.\nNo special symbols or punctuations are used in keywords and identifiers.\nNo special symbols or punctuations are used in keywords and identifiers.  The only underscore can be used in an identifier.\nExample:\nint, char, while, do.\nExample:\ngeeksForGeeks, geeks_for_geeks, gfg, gfg12.\nCreate Quiz\nComment\nV\nvarshachoudhary\nFollow\n62\nImprove\nV\nvarshachoudhary\nFollow\n62\nImprove\nArticle Tags :\nC++\nCPP-Basics",
    "content_length": 3109,
    "scraped_at": "2025-12-07 16:23:46",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Variables",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-variables/",
    "content": "In C++,\nvariable\nis a name given to a memory location. It is the basic unit of storage in a program. The value stored in a variable can be accessed or changed during program execution.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Creating a single character variable\nint\nnum\n=\n3\n;\n// Accessing and printing above variable\ncout\n<<\nnum\n<<\nendl\n;\n// Update the value\nnum\n=\n7\n;\n// Printing the updated value\ncout\n<<\nnum\n;\nreturn\n0\n;\n}\nCreating a Variable\nCreating a variable and giving it a name is called\nvariable definition\n(sometimes called\nvariable declaration\n). The syntax of variable definition is:\nC++\ntype\nname\n;\nwhere,\ntype\nis the type of data that a variable can store, and\nname\nis the name assigned to the variable. Multiple variables of the same type can be defined as:\nC++\ntype\nname1\n,\nname2\n,\nname3\n....;\nThe\ndata type\nof a variable is selected from the list of data types supported by C++.\nTo store number without decimal point, we use integer data type.\nC++\nint\nnum\n;\nHere,\nint\nis the keyword used to tell the compiler that the variable with name\nnum\nwill store integer values. The\nC++ Course\ncovers the types of variables in C++ and how to use them effectively in your programs.\nInitializing\nA variable that is just defined may not contain some valid value.\nWe have to initialize it to some valid initial value. It is done by using an\nassignment operator =\nas shown:\nC++\nint\nnum\n;\nnum\n=\n3\n;\nDefinition and initialization can also be done in a single step as shown:\nC++\nint\nnum\n=\n3\n;\nThe integer variable\nnum\nis initialized with the value 3. Values are generally the\nliterals\nof the same type.\nNote:\nThe value we assign should be of the same type as the variable.\nAccessing and Updating\nThe main objective of a variable is to store the data so that it can be retrieved or update any time. Accessing can be done by simply using its assigned name and updating the value using\n= assignment operator\n.\nC++\nint\nnum\n=\n3\n;\n// Accessing and printing above variable\ncout\n<<\nnum\n<<\nendl\n;\n// Update the value\nnum\n=\n7\n;\ncout\n<<\nnum\n;\nRules For Naming Variable\nThe names given to a variable are called\nidentifiers\n. There are some rules for creating these identifiers (names):\nA name can only contain\nletters\n(A-Z or a-z),\ndigits\n(0-9), and\nunderscores (_)\n.\nIt should start with a\nletter or an underscore only.\nIt is case sensitive.\nThe name of the variable should not contain any whitespace and special characters (i.e. #, $, %, *, etc).\nWe cannot use\nC++ keyword\n(e.g. float, double, class) as a variable name.\nHow are variables used?\nVariables are the names given to the memory location which stores some value. These names can be used in any place where the value it stores can be used.\nFor example,\nwe assign values of the same type to variables. But instead of these values, we can also use variables that store these values.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nnum1\n=\n10\n,\nnum2\n;\n// Assigning num1's value to num2\nnum2\n=\nnum1\n;\ncout\n<<\nnum1\n<<\n\" \"\n<<\nnum2\n;\nreturn\n0\n;\n}\nOutput\n10 10\nAddition of two integers can be done in C++ using\n+ operator\nas shown:\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\ncout\n<<\n10\n+\n20\n;\nreturn\n0\n;\n}\nOutput\n30\nWe can do the above operation using the variables that store these two values.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nnum1\n=\n10\n,\nnum2\n=\n20\n;\ncout\n<<\nnum1\n+\nnum2\n;\nreturn\n0\n;\n}\nOutput\n30\nConstant Variables\nIn C++, a\nconstant variable\nis one whose value cannot be changed after it is initialized. This is done using the\nconst\nkeyword.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nconst\nint\nnum\n=\n10\n;\ncout\n<<\nnum\n;\nreturn\n0\n;\n}\nOutput\n10\nScope of Variables\nScope of variable\nis the region inside the program where the variable can be referred to by using its name. Basically, it is the part of the program where the variable exists. Proper understanding of this concept requires the understanding of other concepts such as functions, blocks, etc.\nMemory Management of Variables\nWhen we create or declare a variable, a fixed-size memory block is assigned to the variable, and its initial value is a garbage value. Initialization assigns a meaningful value using the assignment operator. Variables essentially manipulate specific memory locations, and their stored data is accessed via their names.\nMoreover, different variables may be stored in different section of memory according to its\nstorage class\n.\nCreate Quiz\nVariable Naming Rules\nVisit Course\nVariable Naming Rules\nVariables and Data Types in C++\nComment\nR\nRishabhPrabhu\nFollow\n459\nImprove\nR\nRishabhPrabhu\nFollow\n459\nImprove\nArticle Tags :\nC++\nCPP-Basics",
    "content_length": 4663,
    "scraped_at": "2025-12-07 16:23:48",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Data Types",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-data-types/",
    "content": "Data types specify the type of data that a variable can store. Whenever a variable is defined in C++, the compiler allocates memory for that variable based on the data type with which it is declared. Please note that every may require a different amount of memory.\nBelow is an example of integer data type.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Creating a variable to store integer\nint\nvar\n=\n10\n;\ncout\n<<\nvar\n;\nreturn\n0\n;\n}\nOutput\n10\nExplanation\n: In the above code, we needed to store the value\n10\nin our program, so we created a variable\nvar\n. But before\nvar\n, we have used the keyword '\nint\n'\n.\nThis keyword is used to define that the variable\nvar\nwill store data of type\ninteger\n.\nLet's see how to use some primitive data types in C++ program.\n1. Character Data Type (char)\nThe\ncharacter data type\nis used to store a single character. The keyword used to define a character is\nchar\n. Its size is 1 byte, and it stores characters enclosed in single quotes (' '). It can generally store upto 256 characters according to their\nASCII codes.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Character variable\nchar\nc\n=\n'A'\n;\ncout\n<<\nc\n;\nreturn\n0\n;\n}\nOutput\nA\n2. Integer Data Type (int)\nInteger data type\ndenotes that the given variable can store the integer numbers. The keyword used to define integers is\nint.\nIts size is\n4-bytes\n(for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from\n-2,147,483,648\nto\n2,147,483,647.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Creating an integer variable\nint\nx\n=\n25\n;\ncout\n<<\nx\n<<\nendl\n;\n// Using hexadecimal base value\nx\n=\n0x15\n;\ncout\n<<\nx\n;\nreturn\n0\n;\n}\nOutput\n25\n21\nTo know more about different base values in C++, refer to the article -\nLiterals in C++\n3. Boolean Data Type (bool)\nThe\nboolean data type\nis used to store logical values:\ntrue(1)\nor\nfalse(0)\n. The keyword used to define a boolean variable is\nbool\n. Its size is 1 byte.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Creating a boolean variable\nbool\nisTrue\n=\ntrue\n;\ncout\n<<\nisTrue\n;\nreturn\n0\n;\n}\nOutput\n1\n4. Floating Point Data Type (float)\nFloating-point data type\nis used to store numbers with decimal points. The keyword used to define floating-point numbers is\nfloat\n. Its size is 4 bytes (on 64-bit systems) and can store values in the range from\n1.2e-38\nto\n3.4e+38.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Floating point variable with a decimal value\nfloat\nf\n=\n36.5\n;\ncout\n<<\nf\n;\nreturn\n0\n;\n}\nOutput\n36.5\n5. Double Data Type (double)\nThe\ndouble data type\nis used to store decimal numbers with higher precision. The keyword used to define double-precision floating-point numbers is\ndouble\n. Its size is 8 bytes (on 64-bit systems) and can store the values in the range from\n1.7e-308\nto\n1.7e+308\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// double precision floating point variable\ndouble\npi\n=\n3.1415926535\n;\ncout\n<<\npi\n;\nreturn\n0\n;\n}\nOutput\n3.14159\n6. Void Data Type (void)\nThe\nvoid data type\nrepresents the absence of value. We cannot create a variable of void type. It is used for pointer and functions that do not return any value using the keyword\nvoid\n.\nType Safety in C++\nC++ is a\nstrongly typed language\n. It means that all variables' data type should be specified at the declaration, and it does not change throughout the program. Moreover, we can only assign the values that are of the same type as that of the variable.\nIf we try to assign\nfloating point\nvalue to a boolean variable, it may result in data corruption, runtime errors, or undefined behaviour.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Assigning float value to isTrue\nbool\na\n=\n10.248f\n;\ncout\n<<\na\n;\nreturn\n0\n;\n}\nOutput\n1\nAs we see, the floating-point value is not stored in the bool variable\na.\nIt just stores 1. This type checking is not only done for fundamental types, but for all data types to ensure valid operations and no data corruptions.\nData Type Conversion\nType conversion\nrefers to the process of changing one data type into another compatible one without losing its original meaning. It's an important concept for handling different data types in C++.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nn\n=\n3\n;\nchar\nc\n=\n'C'\n;\n// Convert char data type into integer\ncout\n<<\n(\nint\n)\nc\n<<\nendl\n;\nint\nsum\n=\nn\n+\nc\n;\ncout\n<<\nsum\n;\nreturn\n0\n;\n}\nOutput\n67\n70\nSize of Data Types in C++\nEarlier, we mentioned that the size of the data types is according to the 64-bit systems. Does it mean that the size of C++ data types is different for different computers?\nActually, it is partially true. The size of C++ data types can vary across different systems, depending on the architecture of the computer (e.g., 32-bit vs. 64-bit systems) and the compiler being used. But if the architecture of the computer is same, then the size across different computers remains same.\nWe can find the size of the data type using\nsizeof\noperator. According to this type, the\nrange of values\nthat a variable of given data types can store are decided.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Printing the size of each data type\ncout\n<<\n\"Size of int: \"\n<<\nsizeof\n(\nint\n)\n<<\n\" bytes\"\n<<\nendl\n;\ncout\n<<\n\"Size of char: \"\n<<\nsizeof\n(\nchar\n)\n<<\n\" byte\"\n<<\nendl\n;\ncout\n<<\n\"Size of float: \"\n<<\nsizeof\n(\nfloat\n)\n<<\n\" bytes\"\n<<\nendl\n;\ncout\n<<\n\"Size of double: \"\n<<\nsizeof\n(\ndouble\n)\n<<\n\" bytes\"\n;\nreturn\n0\n;\n}\nOutput\nSize of int: 4 bytes\nSize of char: 1 byte\nSize of float: 4 bytes\nSize of double: 8 bytes\nData Type Modifiers\nData type modifiers\nare the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store. There are 4 type modifiers in C++:\nshort, long, signed\nand\nunsigned.\nFor Example,\ndefining an\nint\nwith\nlong\ntype modifier will change its size to 8 bytes:\nC++\nint\nvar1\n;\n// 4 bytes\nlong\nint\nvar2\n;\n// 8 bytes\nSimilarly, other type modifiers also affect the size or range of the data type.\nlong double, long long int, unsigned int, etc.\nCreate Quiz\nVariables and Data Types in C++\nVisit Course\nComment\nK\nkartik\n1.25k\nImprove\nK\nkartik\n1.25k\nImprove\nArticle Tags :\nC++\nCPP-Basics\nschool-programming\nCBSE - Class 11",
    "content_length": 6333,
    "scraped_at": "2025-12-07 16:23:50",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Operators",
    "url": "https://www.geeksforgeeks.org/cpp/operators-in-cpp/",
    "content": "C++ operators are the symbols that operate on values to perform specific mathematical or logical computations on given values. They are the foundation of any programming language.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n10\n+\n20\n;\ncout\n<<\na\n;\nreturn\n0\n;\n}\nOutput\n30\nExplanation: Here, '\n+\n' is an\naddition operator\nand does the addition of 10 and 20 operands and return value 30 as a result.\nC++ Operator Types\nC++ operators are classified into\n6 types\non the basis of type of operation they perform:\n1. Arithmetic Operators\nArithmetic operators\nare used to perform arithmetic or mathematical operations on the operands. For example, '\n+\n' is used for addition.\nAddition\n, +, Adds two operands\nSubtraction\n, -, Subtracts second operand from the first\nMultiplication\n, *, Multiplies two operands\nDivision\n, /, Divides first operand by the second operand\nModulo Operation\n, %, Returns the remainder of an integer division\nIncrement\n, ++, Increases the value of operand by 1\nDecrement\n, --, Decreases the value of operand by 1\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n8\n,\nb\n=\n3\n;\n// Addition\ncout\n<<\n\"a + b = \"\n<<\n(\na\n+\nb\n)\n<<\nendl\n;\n// Subtraction\ncout\n<<\n\"a - b = \"\n<<\n(\na\n-\nb\n)\n<<\nendl\n;\n// Multiplication\ncout\n<<\n\"a * b = \"\n<<\n(\na\n*\nb\n)\n<<\nendl\n;\n// Division\ncout\n<<\n\"a / b = \"\n<<\n(\na\n/\nb\n)\n<<\nendl\n;\n// Modulo\ncout\n<<\n\"a % b = \"\n<<\n(\na\n%\nb\n)\n<<\nendl\n;\n// Increament\ncout\n<<\n\"++a = \"\n<<\n++\na\n<<\nendl\n;\n// Decrement\ncout\n<<\n\"b-- = \"\n<<\nb\n--\n;\nreturn\n0\n;\n}\nOutput\na + b = 11\na - b = 5\na * b = 24\na / b = 2\na % b = 2\n++a = 9\n--b = 2\nImportant Points:\nThe\nModulo operator\n(%) operator should only be used with integers. Other operators can also be used with floating point values.\n++a\nand\na++\n, both are increment operators, however, both are slightly different. In\n++a\n, the value of the variable is incremented first and then it is used in the program. In\na++\n, the value of the variable is assigned first and then it is incremented. Similarly happens for the decrement operator.\nYou may have noticed that some operator works on two operands while other work on one. On the basis of this operators are also classified as:\nUnary\n: Works on single operand.\nBinary: Works on two operands.\nTernary: Works on three operands.\n2. Relational Operators\nRelational operators\nare used for the comparison of the values of two operands. For example, '>' check right operand is greater.\nIs Equal To\n, ==, Checks if both operands are equal\nGreater Than\n, >, Checks if the first operand is greater than the second operand\nGreater Than or Equal To\n, >=, Checks if the first operand is greater than or equal to the second operand\nLess Than\n, <, Checks if the first operand is lesser than the second operand\nLess Than or Equal To\n, <=, Checks if the first operand is lesser than or equal to the second operand\nNot Equal To\n, !=, Checks if both operands are not equal\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n6\n,\nb\n=\n4\n;\n// Equal operator\ncout\n<<\n\"a == b is \"\n<<\n(\na\n==\nb\n)\n<<\nendl\n;\n// Greater than operator\ncout\n<<\n\"a > b is \"\n<<\n(\na\n>\nb\n)\n<<\nendl\n;\n// Greater than Equal to operator\ncout\n<<\n\"a >= b is \"\n<<\n(\na\n>=\nb\n)\n<<\nendl\n;\n//  Lesser than operator\ncout\n<<\n\"a < b is \"\n<<\n(\na\n<\nb\n)\n<<\nendl\n;\n// Lesser than Equal to operator\ncout\n<<\n\"a <= b is \"\n<<\n(\na\n<=\nb\n)\n<<\nendl\n;\n// Not equal to operator\ncout\n<<\n\"a != b is \"\n<<\n(\na\n!=\nb\n);\nreturn\n0\n;\n}\nOutput\na == b is 0\na > b is 1\na >= b is 1\na < b is 0\na <= b is 0\na != b is 1\nNote: 0 denotes false and 1 denotes true.\n3. Logical Operators\nLogical operators\nare used to combine two or more conditions or constraints or to complement the evaluation of the original condition in consideration. The result returns a Boolean value, i.e., true or false.\nLogical AND\n, &&, Returns true only if all the operands are true or non-zero\nLogical OR\n, ||, Returns true if either of the operands is true or non-zero\nLogical NOT\n, !, Returns true if the operand is false or zero\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n6\n,\nb\n=\n4\n;\n// Logical AND operator\ncout\n<<\n\"a && b is \"\n<<\n(\na\n&&\nb\n)\n<<\nendl\n;\n// Logical OR operator\ncout\n<<\n\"a || b is \"\n<<\n(\na\n||\nb\n)\n<<\nendl\n;\n// Logical NOT operator\ncout\n<<\n\"!b is \"\n<<\n(\n!\nb\n);\nreturn\n0\n;\n}\nOutput\na && b is 1\na || b is 1\n!b is 0\n4. Bitwise Operators\nBitwise operators\nare works on bit-level. So, compiler first converted to bit-level and then the calculation is performed on the operands.\nBinary AND\n, &, Copies a bit to the result if it exists in both operands\nBinary OR\n, |, Copies a bit to the result if it exists in any of the operands\nBinary XOR\n, ^, Copies the bit to the result if it is present in either of the operands but not both\nLeft Shift\n, <<, Shifts the value to the left by the number of bits specified by the right operand\nRight Shift\n, >>, Shifts the value to the right by the number of bits specified by the right operand\nOne's Complement\n,\n~\n, Changes binary digits 1 to 0 and 0 to 1\nNote:\nOnly char and int data types can be used with Bitwise Operators.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n6\n,\nb\n=\n4\n;\n// Binary AND operator\ncout\n<<\n\"a & b is \"\n<<\n(\na\n&\nb\n)\n<<\nendl\n;\n// Binary OR operator\ncout\n<<\n\"a | b is \"\n<<\n(\na\n|\nb\n)\n<<\nendl\n;\n// Binary XOR operator\ncout\n<<\n\"a ^ b is \"\n<<\n(\na\n^\nb\n)\n<<\nendl\n;\n// Left Shift operator\ncout\n<<\n\"a << 1 is \"\n<<\n(\na\n<<\n1\n)\n<<\nendl\n;\n// Right Shift operator\ncout\n<<\n\"a >> 1 is \"\n<<\n(\na\n>>\n1\n)\n<<\nendl\n;\n// One’s Complement operator\ncout\n<<\n\"~(a) is \"\n<<\n~\n(\na\n);\nreturn\n0\n;\n}\nOutput\na & b is 4\na | b is 6\na ^ b is 2\na<<1 is 12\na>>1 is 3\n~(a) is -7\n5. Assignment Operators\nAssignment operators\nare used to assign value to a variable. We assign the value of right operand into left operand according to which assignment operator we use.\nAssignment\n, =, Assigns the value on the right to the variable on the left\nAdd and Assignment\n, +=, Adds the right operand to the left operand and assigns the result to the left operand\nSubtract and Assignment\n, -=, Subtracts the right operand from the left operand and assigns the result to the left operand\nMultiply and Assignment\n, *=, Multiplies the left operand by the right operand and assigns the result to the left operand\nDivide and Assignment\n, /=, Divides the left operand by the right operand and assigns the result to the left operand\nC++\n#include\n<iosteam>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n6\n,\nb\n=\n4\n;\n// Assignment Operator.\ncout\n<<\n\"a = \"\n<<\na\n<<\nendl\n;\n//  Add and Assignment Operator.\ncout\n<<\n\"a += b is \"\n<<\n(\na\n+=\nb\n)\n<<\nendl\n;\n// Subtract and Assignment Operator.\ncout\n<<\n\"a -= b is \"\n<<\n(\na\n-=\nb\n)\n<<\nendl\n;\n//  Multiply and Assignment Operator.\ncout\n<<\n\"a *= b is \"\n<<\n(\na\n*=\nb\n)\n<<\nendl\n;\n//  Divide and Assignment Operator.\ncout\n<<\n\"a /= b is \"\n<<\n(\na\n/=\nb\n);\nreturn\n0\n;\n}\nOutput\na = 6\na += b is 10\na -= b is 6\na *= b is 24\na /= b is 6\n6. Ternary or Conditional Operators\nConditional operator\nreturns the value, based on the condition. This operator takes\nthree operands\n, therefore it is known as a\nTernary Operator\n.\nSyntax:\nC++\nExpression1\n?\nExpression2\n:\nExpression3\nIn the above statement:\nThe ternary operator\n?\ndetermines the answer on the basis of the evaluation of\nExpression1\n.\nIf\nExpression1\nis true, then\nExpression2\ngets evaluated.\nIf\nExpression1\nis false, then\nExpression3\ngets evaluated.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\na\n=\n3\n,\nb\n=\n4\n;\n// Conditional Operator\nint\nresult\n=\n(\na\n<\nb\n)\n?\nb\n:\na\n;\ncout\n<<\n\"The greatest number \"\n\"is \"\n<<\nresult\n;\nreturn\n0\n;\n}\nOutput\nThe greatest number is 4\nMiscellaneous Operators\nApart from these operators, there are a few operators that do not fit in any of the above categories. These are:\n1. sizeof Operator\nsizeof operator\nis a unary operator used to compute the size of its operand or variable in bytes. For example,\nC++\nsizeof\n(\nchar\n);\nsizeof\n(\nvar_name\n);\n2. Comma Operator (,)\nComma operator\nis a binary operator that is used for multiple purposes. It is used as a separator or used to evaluate its first operand and discards the result; it then evaluates the second operand and returns this value (and type).\nC++\nint\nn\n=\n(\nm\n+\n1\n,\nm\n-2\n,\nm\n+\n5\n);\nint\na\n,\nb\n,\nc\n;\n3. Addressof Operator (&)\nAddressof operator\nis used to find the memory address in which a particular variable is stored. In C++, it is also used to create a\nreference\n.\nC++\n&\nvar_name\n;\n4. Dot Operator(.)\nDot operator\nis used to access members of structure variables or class objects using their object names.\nC++\nobj\n.\nmember\n;\n5. Arrow Operator\nArrow operator\nis used to access the variables of classes or structures through its pointer.\nC++\nsptr\n->\nmember\n;\n6. Casting Operators\nCasting operators\nare used to convert the value of one data type to another data type. For example, for an integer value x:\nC++\n(\nfloat\n)\nx\nstatic_cast\n<\nfloat\n>\n(\nx\n)\nOperator Precedency and Associativity\nWhen there are multiple operators in a single expression,\noperator precedency and associativity\ndecide in which order and which part of expression are calculate. Precedency tells which part of expression should be calculate first and associativity tells which direction to solve when same precedency operators are in expression.\nOperator Precedence\nOperator precedence says which operation is calculate first in the expression when expression have different precedency operators. For example:\n3 * 2 + 8;\nWill be evaluated as:\n(3 * 2) + 8 = 14\nIt is because\nmultiplication (*)\nhave higher precedency then\naddition (+).\nOperator Associativity\nOperator associativity says if expression have more than one operator with same precedence then calculation happen in\nright to left\nor\nleft to right.\n50 / 25 * 2\n= 1\nWill be evaluated as:\n(50 / 25) * 2\nCreate Quiz\nOperators in C++\nVisit Course\nComment\nA\nanshikajain26\nFollow\n52\nImprove\nA\nanshikajain26\nFollow\n52\nImprove\nArticle Tags :\nMisc\nC++\ncpp-operator",
    "content_length": 9863,
    "scraped_at": "2025-12-07 16:23:56",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Basic Input / Output",
    "url": "https://www.geeksforgeeks.org/cpp/basic-input-output-c/",
    "content": "Try it on GfG Practice\nIn C++, data is read and written using streams, which are sequences of bytes.\nInput stream:\nData flows from a device (like the keyboard) to the computer’s memory.\nOutput stream:\nData flows from memory to an output device (like the screen).\nThese streams are defined in the\n<iostream>\nheader file.\nThe most common stream objects are - cin : for taking input, cout : for displaying output.\nStandard Output Stream - cout\ncout\nis an instance of the\nostream\nclass used to display output on the screen.\nData is sent to\ncout\nusing the insertion operator\n<<\n.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Printing the given text using cout\ncout\n<<\n\"GeeksforGeeks\"\n;\nreturn\n0\n;\n}\nOutput\nGeeksforGeeks\nStandard Input Stream - cin\ncin is an instance of the istream class used to read input from the keyboard.\nThe extraction operator >> is used with cin to get data from the input stream and store it in a variable.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nage\n;\n// Taking input from user and store it in variable\ncin\n>>\nage\n;\n// Output the entered age\ncout\n<<\n\"Age entered: \"\n<<\nage\n;\nreturn\n0\n;\n}\nOutput\n18\n(Enter by user)\nYour age is: 18\nUn-buffered Standard Error Stream - cerr\ncerr is the standard error stream used to display error messages. It is an instance of the ostream class.\ncerr displays messages immediately, without waiting (Unbuffered output)\nUseful for showing errors or warnings separately from normal program output (cout).\nUnlike cout, which may delay output due to buffering, cerr ensures errors are seen instantly.\nNote:\nThe main difference between cerr and cout comes when you would like to redirect output using \"cout\" that gets redirected to file if you use \"cerr\" the error doesn't get stored in file.(This is what un-buffered means ..It cant store the message)\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\ncerr\n<<\n\"An error occurred\"\n;\nreturn\n0\n;\n}\nError\nAn error occurred\nBuffered Standard Error Stream - clog\nclog is the standard logging stream used to display error or log messages. It is an instance of the ostream class, like cerr.\nMessages are first stored in a buffer and displayed only when the buffer is full or explicitly flushed using flush() (Buffered output)\nUseful for logging messages that don’t need to appear immediately on the screen.\nUnlike cerr, output from clog may be delayed due to buffering.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nclog\n<<\n\"An error occurred\"\n;\nreturn\n0\n;\n}\nError\nAn error occurred\nRead related article\nDifference between cerr and clog\nCreate Quiz\nInput Output Introduction in C++\nVisit Course\nComment\nH\nHarsh Agarwal\n723\nImprove\nH\nHarsh Agarwal\n723\nImprove\nArticle Tags :\nMisc\nC++\ncpp-input-output\nCPP-Basics\nschool-programming\nCBSE - Class 11\n+2 More",
    "content_length": 2808,
    "scraped_at": "2025-12-07 16:23:59",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Conditional Statements",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-decision-making/",
    "content": "Try it on GfG Practice\nDecision-making is the process to make a decision about which part of the code should be executed or not based on some condition. Decision-making in C++ involves the usage of\nconditional statements\n(also called decision control statements) to execute specific blocks of code primarily based on given situations and their results.\nIn C++, the following decision-making statements are available:\n1. if Statement\nIn C++, the\nif statement\nis the simplest decision-making statement. It allows the execution of a block of code if the given condition is true. The body of the if statement is executed only if the given condition is true.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nage\n=\n19\n;\n// Check if age is greater than 18 fo\n// vote eligiblity\nif\n(\nage\n>\n18\n)\n{\ncout\n<<\n\"allowed to vote\"\n;\n}\nreturn\n0\n;\n}\nOutput\nallowed to vote\nWe can skip to write curly brasses if there is only line statement inside the curly brasses.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nage\n=\n19\n;\nif\n(\nage\n>\n18\n)\ncout\n<<\n\"allowed to vote\"\n;\nreturn\n0\n;\n}\nOutput\nallowed to vote\nFlowchart:\n2. if-else Statement\nThe\nif else\nis adecision-making statement allows us to make a decision based on the evaluation of a given condition. If the given condition evaluates to true then the code inside the 'if' block is executed and in case the condition is false, the code inside the 'else' block is executed.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nn\n=\n5\n;\n// Using if-else to determine if the number is positive\n// or non positive\nif\n(\nn\n>\n0\n)\n{\ncout\n<<\n\"number is positive.\"\n;\n}\nelse\n{\ncout\n<<\n\"number is non-positive.\"\n;\n}\nreturn\n0\n;\n}\nOutput\nnumber is positive.\nFlowchart:\n3. if else if Ladder\nThe\nif else if Ladder\nstatements allow us to include additional situations after the preliminary if condition. The 'else if' condition is checked only if the above condition is not true, and the `else` is the statement that will be executed if none of the above conditions is true. If some condition is true, then not only the associated block is executed.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nage\n=\n18\n;\n// if this condition is true child is printed\nif\n(\nage\n<\n13\n)\n{\ncout\n<<\n\"child\"\n;\n}\n// if above above if statement is not true then we check\n// this else if condition if it evalutes to true print\n// growing age\nelse\nif\n(\nage\n>=\n1\nand\nage\n<=\n18\n)\n{\ncout\n<<\n\"Growing stage\"\n;\n}\n// if none of above condition is true print adult\nelse\n{\ncout\n<<\n\"adult\"\n;\n}\nreturn\n0\n;\n}\nOutput\nGrowing stage\nFlowchart:\n4. Nested if else\nThe\nnested if else statement\ncontains an 'if' statement inside another 'if' statement. This structure lets in more complex selection-making by way of comparing multiple conditions. In this type of statement, multiple conditions are checked, and then the body of the last if statement is executed.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nn\n=\n44\n;\n// to check if n is positive\nif\n(\nn\n>\n0\n)\n{\n// to check if the positive n is even or odd\nif\n(\nn\n%\n2\n==\n0\n)\n{\ncout\n<<\n\"positive and even number\"\n;\n}\nelse\n{\ncout\n<<\n\"positive and odd number\"\n;\n}\n}\n// to check if the n is 0\nelse\nif\n(\nn\n==\n0\n)\n{\ncout\n<<\n\"the number is zero\"\n;\n}\n// to check if the n is negative\nelse\n{\ncout\n<<\n\"the number is negative\"\n;\n}\nreturn\n0\n;\n}\nOutput\npositive and even number\nFlowchart:\n5. Switch Statement\nIn C++, the\nswitch statement\nis used when multiple situations need to be evaluated primarily based on the value of a variable or an expression. switch statement acts as an alternative to multiple if statements or if-else ladder and has a cleaner structure and it is easy for handling multiple conditions.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nchar\nc\n=\n'B'\n;\nswitch\n(\nc\n)\n{\n// if the input character is A then print GFG\ncase\n'A'\n:\ncout\n<<\n\"GFG\"\n;\nbreak\n;\n// if the input character is B then print\n// GeeksforGeeks\ncase\n'B'\n:\ncout\n<<\n\"GeeksforGeeks\"\n;\nbreak\n;\ndefault\n:\n// if the input character is invalid then print\n// invalid input\ncout\n<<\n\"invalid input\"\n;\n}\nreturn\n0\n;\n}\nOutput\nGeeksforGeeks\nFlowchart:\n6. Ternary Operator ( ? : )\nThe\nconditional operator\nis also known as a\nternary operator\n. It is used to write conditional operations provided by C++. The '?' operator first checks the given condition, if the condition is true then the first expression is executed otherwise the second expression is executed. It is an alternative to an if-else condition in C++.\nC++\nexpression\n?\nstatement_1\n:\nstatement_2\n;\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nint\nnum1\n=\n10\n,\nnum2\n=\n40\n;\nint\nmax\n;\n// if the condition is true then num1 will be printed\n// else num2 will printed\nmax\n=\n(\nnum1\n>\nnum2\n)\n?\nnum1\n:\nnum2\n;\ncout\n<<\nmax\n;\nreturn\n0\n;\n}\nOutput\n40\nRecommended Links\nJump statements in C++\nLoops in C++\nCreate Quiz\nDecision Making in C++\nComment\nA\namritkumasakv\nFollow\n74\nImprove\nA\namritkumasakv\nFollow\n74\nImprove\nArticle Tags :\nC++\nGeeks Premier League\nCPP-Basics\nGeeks Premier League 2023",
    "content_length": 5027,
    "scraped_at": "2025-12-07 16:24:05",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Functions",
    "url": "https://www.geeksforgeeks.org/cpp/functions-in-cpp/",
    "content": "A Function is a reusable block of code designed to perform a specific task. It helps break large programs into smaller, logical parts. Functions make code cleaner, easier to understand, and more maintainable.\nJust like in other languages, C++ functions can take inputs (called parameters), execute a block of statements, and optionally return a result. C++ also supports advanced features like\nfunction overloading\n,\ndefault arguments\n, and\ninline functions\n, which give more flexibility compared to C.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Void function definition\nvoid\nhello\n()\n{\ncout\n<<\n\"GeeksforGeeks\"\n<<\nendl\n;\n}\n// Return-type function definition\nint\nsquare\n(\nint\nx\n)\n{\nreturn\nx\n*\nx\n;\n}\nint\nmain\n()\n{\n// Calling the void function\nhello\n();\n// Calling the return-type function\nint\nresult\n=\nsquare\n(\n5\n);\ncout\n<<\n\"Square of 5 is: \"\n<<\nresult\n<<\nendl\n;\nreturn\n0\n;\n}\nOutput\nGeeksforGeeks\nSquare of 5 is: 25\nIn the above example, there are three functions:\nmain() function:\nThis is the entry point of every C++ program. When the program runs, execution starts from the main function. It contains the calls to the other functions.\nhello() function:\nThis is a user-defined function that does not take any parameters and does not return a value. It simply prints \"GeeksforGeeks\" to the console. The return type void indicates that it doesn't return anything.\nsquare(int x) function:\nThis is another user-defined function that takes an integer as input and returns the square of that number. The return type int means the function will return an integer value. In main(), the function is called with the value 5, and the returned result is stored in a variable and printed.\nUnderstanding Function Structure and Usage\nTo work with functions in C++, it is important to understand how they are written, declared, and called. This section covers function syntax, declaration vs definition, and how to call a function in a program.\nFunction Syntax in C++\nA function in C++ follows this general format:\nC++\nreturn_type\nfunction_name\n(\nparameter_list\n)\n{\n// body of the function\n}\nEach part has a specific role:\nReturn type\n: Specifies what type of value the function returns. Use void if there is no return value.\nFunction name\n: The name you will use to call the function.\nParameter list\n: Inputs that the function accepts. It can be empty if no inputs are needed.\nFunction body\n: The block of code that runs when the function is called.\nFunction Declaration vs Definition\nFunction Declaration\nintroduces the function to the compiler. It tells the compiler the return type, name, and parameters but does not include the body. It ends with a semicolon.\nC++\n// Declaration\nint\nadd\n(\nint\n,\nint\n);\nFunction Definition\nprovides the actual implementation of the function.\nC++\nint\nadd\n(\nint\na\n,\nint\nb\n)\n{\nreturn\na\n+\nb\n;\n}\nDeclaration is useful when the function is defined later in the code or in a separate file.\nWhy is Declaration Needed in C++?\nIn C++, if a function is defined after the main function or any other function that tries to use it, the compiler will not recognize it unless a declaration is provided earlier in the code. This declaration tells the compiler about the function's name, return type, and parameters in advance.\nFunction declarations are especially useful in larger programs where functions are defined later in the file or in separate source files. By declaring the function before it's used, the compiler can ensure the function is called correctly.\nIn simple terms, the\ndeclaration introduces the function to the compiler\n, while the\ndefinition provides the actual implementation\n.\nCalling a Function\nOnce a function is defined, you can use it by simply calling its name followed by parentheses. This tells the program to execute the code inside that function.\nIf the function takes parameters, you pass the required values inside the parentheses. If it doesn’t take any parameters, you just use empty parentheses.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Function with no parameters and no return value\nvoid\ngreet\n()\n{\ncout\n<<\n\"Welcome to C++ Programming!\"\n<<\nendl\n;\n}\n// Function with parameters and a return value\nint\nmultiply\n(\nint\na\n,\nint\nb\n)\n{\nreturn\na\n*\nb\n;\n}\nint\nmain\n()\n{\n// Calling the greet function\ngreet\n();\n// Calling the multiply function\nint\nresult\n=\nmultiply\n(\n4\n,\n5\n);\ncout\n<<\n\"Multiplication result: \"\n<<\nresult\n<<\nendl\n;\nreturn\n0\n;\n}\nOutput\nWelcome to C++ Programming!\nMultiplication result: 20\nIn above example, two functions are defined and called:\ngreet() function:\nThis function does not take any parameters and does not return a value. It simply prints a welcome message. It is called in main() using greet();.\nmultiply(int a, int b) function:\nThis function takes two integers as input, multiplies them, and returns the result. In main(), it is called with the values 4 and 5, and the returned value is stored in the variable result, which is then printed.\nFunction calls allow you to reuse code easily. You can call the same function multiple times with different inputs to perform repeated tasks in a structured and clean way.\nTypes of Functions in C++\nIn C++, functions can be broadly categorized based on two criteria:\n1. Based on origin\nLibrary Functions\n: These are built-in functions provided by C++ standard libraries, such as\ncout\n,\nsqrt()\n,\nabs()\n, and\ngetline()\n. You can use them by including appropriate\nheaders\nlike <iostream>, <cmath>, or <string>.\nUser-Defined Functions\n: These are functions created by the programmer to perform specific tasks in the program.\n2. Based on input and return type\nUser-defined functions can be further classified based on whether they accept parameters or return a value:\nNo parameters, no return value:\nThe function performs a task but does not take input or return anything.\nParameters, no return value:\nThe function takes input but does not return a result.\nNo parameters, return value:\nThe function returns a result but does not take any input.\nParameters and return value:\nThe function takes input and returns a result.\nThese types help you design functions according to the task they need to perform. Choosing the right form improves code flexibility and clarity.\nParameters or Arguments\nA function can also take some input data to process. These values are called\nfunction arguments\nand are supplied to the function at the function call. To receive these values, we define placeholder variables called\nparameter\ninside parenthesis in function definition. They should be specified with their types and names.\nC++\nreturn_type\nname\n(\ntype1\nname1\n,\ntype2\nname2\n...)\n{\n// Function body\nreturn\nval\n;\n}\nname1\n,\nname2\nand so on are the parameter names using which they will be accessed in the function.\nExample:\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Defining function that prints given number\nvoid\nprintNum\n(\nint\nn\n){\ncout\n<<\nn\n<<\nendl\n;\n}\nint\nmain\n()\n{\nint\nnum1\n=\n10\n;\nint\nnum2\n=\n99\n;\n// Calling printNum and passing both\n// num1 and num2 to it one by one\nprintNum\n(\nnum1\n);\nprintNum\n(\nnum2\n);\nreturn\n0\n;\n}\nOutput\n10\n99\nIn the above program,\nprintNum()\nfunction is defined with one integer parameter\nn\nthat it prints. It means that it will take one value of integer type while calling and print it. We called\nprintNum()\ntwo times, one with\nnum1\nand one with\nnum2\n, and in each call, it prints the given number.\nNote:\nWe refer to the passed argument using the name\nn\nnot\nnum1\nor\nnum2\nin the function. It is due to the concept called\nscope of variables\nin the\nmain\nand\nprintNum()\nfunction.\nHere, there can be one question. Why didn't we call the function with both numbers at once? The answer lies in the\nprintNum()\ndefinition. We have defined the function that only takes one value of integer type as parameter, so we cannot pass two values. In other words,\nA function can only take as many arguments as specified in the function definition and it is compulsory to pass them while calling it. Also, they should be of same type as in the function definition.\nThere are also other different ways to pass arguments to the function in C++. Refer to this article to know more -\nParameter Passing Techniques in C++\nLambda Functions in C++\nFunctions in C++ are declared and defined in global scope or class scope. So, C++ 11 introduced\nlambda expressions\nto allow inline functions which can be used for short snippets of code that are not going to be reused. Therefore, they do not require a name. They are mostly used in STL algorithms as callback functions.\nNote:\nThe concepts covered above focus on function types and uses within procedural programming. However, C++ also supports advanced features like\nfunction overloading\n,\ndefault arguments\n,\ninline functions\n, and\nmember functions\nwithin classes. These features are part of\nC++'s object-oriented programming\ncapabilities and will be covered separately in dedicated sections.\nCreate Quiz\nFunctions in C++\nVisit Course\nFunctions in C++\nApplications of Functions.\nHow Functions Work in C++?\nComment\nK\nkartik\nFollow\n530\nImprove\nK\nkartik\nFollow\n530\nImprove\nArticle Tags :\nC++\nCPP-Functions",
    "content_length": 9054,
    "scraped_at": "2025-12-07 16:24:09",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Parameter Passing Techniques",
    "url": "https://www.geeksforgeeks.org/cpp/parameter-passing-techniques-in-cpp/",
    "content": "In C++, data can be sent to functions when they are called in order to perform operations. This data is called parameters or arguments and there are various parameter passing methods available in C++. In this article, we will discuss various parameter-passing techniques in C++.\nBefore you see the techniques, first understand the difference between the following terms:\nFormal Parameters:\nVariables used in parameter list of a function as placeholders. Also called\nonly parameters.\nActual Parameters:\nThe expressions or values passed in during a function call. Also called\narguments\n.\nThere are 3 different methods using which we can pass parameters to a function in C++. These are:\n1. Pass by Value\nIn\npass by value\nmethod, a variable's value is copied and then passed to the function. As the result, any changes to the parameter inside the function will not affect the variable's original value in the caller. This method is simple, easy to understand and implement but it is not preferred for large size of data structures at it involves copying the value.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Arguments are pass by value\nvoid\nchange\n(\nint\na\n)\n{\n// Modifying arguments\na\n=\n22\n;\n}\nint\nmain\n()\n{\nint\nx\n=\n5\n;\n// Passing x by value to change()\nchange\n(\nx\n);\ncout\n<<\nx\n;\nreturn\n0\n;\n}\nOutput\n5\nIn this program, when the change function is called with\nx\nas the argument, a copy of\nx\nis created and passed to the function. Inside the function, the parameter a is modified, but this modification only affects the local copy of the value, not the original variable\nx,\nas demonstrated by the output.\n2. Pass b\ny Reference\nIn pass-by-reference method, instead of passing the value of the argument, we pass the reference of an argument to the function. This allows the function to change the value of the original argument. This is useful when you have to pass large size data.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Arguments are pass by value\nvoid\nchange\n(\nint\n&\na\n)\n{\n// Modifying arguments\na\n=\n22\n;\n}\nint\nmain\n()\n{\nint\nx\n=\n5\n;\n// Passing x by reference to change()\nchange\n(\nx\n);\ncout\n<<\nx\n;\nreturn\n0\n;\n}\nOutput\n22\nAs we can see, the original value is modified. Just declaring the parameter\na\nas a reference changes it from pass by value to pass by reference.\n3. Pass by Pointer\nThe pass-by-pointer is very similar to the pass-by-reference method. The only difference is that we pass the raw address of the argument as the parameter to the function instead of reference.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Arguments are pass by value\nvoid\nchange\n(\nint\n*\na\n)\n{\n// Modifying arguments\n*\na\n=\n22\n;\n}\nint\nmain\n()\n{\nint\nx\n=\n5\n;\n// Passing address of x to change()\nchange\n(\n&\nx\n);\ncout\n<<\nx\n;\nreturn\n0\n;\n}\nOutput\n22\nThe original value is modified, but it increased to complexity of the program as we need to be careful of referencing, referencing and passing addresses. So, passing reference is preferred over this method.\nCreate Quiz\nComment\nK\nkumardhanshiv\nFollow\n6\nImprove\nK\nkumardhanshiv\nFollow\n6\nImprove\nArticle Tags :\nC++",
    "content_length": 3050,
    "scraped_at": "2025-12-07 16:24:11",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Default Arguments",
    "url": "https://www.geeksforgeeks.org/cpp/default-arguments-c/",
    "content": "A default argument is a value provided for a parameter in a function declaration that is automatically assigned by the compiler if no value is provided for those parameters in function.\nDefault arguments must be present on the right side only. Once a default argument is provided, all the arguments to its right must also be defaults.\nIt is recommended to specify them in function declaration (usually in the header).\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Function with an argument\n// with default value\nvoid\nf\n(\nint\na\n=\n10\n)\n{\ncout\n<<\na\n<<\nendl\n;\n}\nint\nmain\n()\n{\n// Uses default argument\nf\n();\n// Uses passed value\nf\n(\n221\n);\nreturn\n0\n;\n}\nOutput\n10\n221\nExplanation\n: In this program, the function f has a default argument a = 10, so when no argument is provided, a defaults to 10, which is printed. When 221 is passed, a becomes 221 which is then printed.\nSyntax\nA default argument is defined by assigning a value to a function parameter in its declaration.\nC++\nreturn_type\nname\n(\np1\n=\nv1\n,\np2\n=\nv2\n,\n...);\nwhere\nv1, v2, ...\nare the default values for the parameters\np1, p2,\n... respectively.\nRules to Follow\nThere are some important rules and best practices to keep in mind when using default arguments in C++:\n1. Default Values Should be Specified in Function Declarations\nThe default values for parameters should be specified in the function declaration (or prototype). If a function is declared and defined separately, the default values must be in the declaration, not in definition.\nC++\n// Declaration with default argument\nvoid\nfunc\n(\nint\nx\n=\n10\n);\n// Definition without default argument\nvoid\nfunc\n(\nint\nx\n)\n{\ncout\n<<\n\"Value: \"\n<<\nx\n<<\nendl\n;\n}\n2. Default Arguments Cannot Be Modified\nOnce default arguments are defined in the declaration, they cannot be modified in the function definition. If you try to change the default value in the definition, it will result in a compilation error.\nC++\n// Declaration\nvoid\nf\n(\nint\na\n=\n10\n);\n// This definintion will throw and error\nvoid\nf\n(\nint\na\n=\n222\n)\n{\n// statements\n}\n3. Default Arguments Must Be Provided from Right to Left\nIn a function with multiple parameters, default values must be provided from the rightmost parameter to the left. It means that if a parameter has a default argument, all parameters to its right must also have default values.\nC++\n// Valid\nvoid\nfunc\n(\nint\nx\n,\nint\ny\n=\n20\n);\n// Invalid, as `y` does not have a default value\nvoid\nfunc\n(\nint\nx\n=\n10\n,\nint\ny\n);\n4. Ambiguity in Function Overloading\nIf a function containing default arguments is overloaded, then we need to make sure it is not ambiguous to the compiler, otherwise it will throw an error.\nC++\n// Valid\nvoid\nf\n(\nint\na\n=\n10\n,\nint\nb\n=\n20\n);\n// Will throw error as the signature is same\nvoid\nf\n(\nint\na\n=\n22\n,\nint\nb\n=\n2\n);\n// Will also throw error\nvoid\nf\n(\nint\na\n);\n// Will also throw an error\nvoid\nf\n(\nint\na\n,\nb\n)\nExamples\nThe following examples demonstrate the use of default arguments in different cases:\nFind Area of Rectangle with Optional Length\nWe want to keep the rectangle height optional in case it is not provided to the area calculator function. One approach could be to create two overloaded functions, one that takes two parameters and one that takes one. However, this can be simplified by using default arguments instead of\nfunction overloading\nby specifying optional values.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\n// Function with default height 'h' argument\ndouble\ncalcArea\n(\ndouble\nl\n,\ndouble\nh\n=\n10.0\n)\n{\nreturn\nl\n*\nh\n;\n}\nint\nmain\n()\n{\ncout\n<<\n\"Area 1:  \"\n<<\ncalcArea\n(\n5\n)\n<<\nendl\n;\ncout\n<<\n\"Area 2: \"\n<<\ncalcArea\n(\n5\n,\n9\n);\nreturn\n0\n;\n}\nOutput\nArea 1:  50\nArea 2: 45\nCombine Default and Parameterized Constructor\nJust like normal functions, we can also define default values for the arguments of\nparameterized constructors\n. All the rules of the default arguments will be applied to these parameters.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nclass\nA\n{\npublic\n:\nint\ndata\n;\n// Parameterized constructor with default values\nA\n(\nint\nx\n=\n5\n)\n{\ndata\n=\nx\n;\n}\n};\nint\nmain\n()\n{\nA\na1\n;\nA\na2\n(\n25\n);\ncout\n<<\na1\n.\ndata\n<<\nendl\n;\ncout\n<<\na2\n.\ndata\n;\nreturn\n0\n;\n}\nOutput\n5\n25\nExplanation:\nIn the above program, we create a class with a parameterized constructor that has a default argument. When we create an object without passing any argument, the constructor uses its default value of x = 5. However, when we pass an argument, the constructor uses the passed value of x = 25.\nIf the default values are not well-documented or understood, it can lead to confusion about what arguments are being used.\nCan default arguments be specified in the function definition?\nNo, default values should only appear in the declaration.\nWhat happens if a function with default arguments is called with extra arguments?\nIf you provide more arguments than the function expects, the provided arguments are used for the corresponding parameters, and the remaining parameters use their default values.\nCan default arguments be used with overloaded functions?\nYes, but be cautious of ambiguity. Overloaded functions with default arguments can cause confusion if the compiler can't determine which version to call.\nWhat happens when default arguments are used in virtual functions in C++?\nDefault arguments can be used in virtual functions. However, when a derived class overrides a base class function, the default arguments of the base class are not inherited. If the derived class provides new default arguments, it may lead to different behaviour.\nCan default arguments be used for template parameters?\nYes, default arguments can be specified for\ntemplate\nparameters as well.\nCreate Quiz\nDefault Arguments in C++ Functions\nVisit Course\nComment\nK\nkartik\nFollow\n221\nImprove\nK\nkartik\nFollow\n221\nImprove\nArticle Tags :\nC++\nCPP-Functions",
    "content_length": 5778,
    "scraped_at": "2025-12-07 16:24:14",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Recursion",
    "url": "https://www.geeksforgeeks.org/cpp/cpp-recursion/",
    "content": "Recursion\nis a programming technique where a function calls itself repeatedly until a specific base condition is met. A function that performs such self-calling behavior is known as a\nrecursive function\n, and each instance of the function calling itself is called a\nrecursive call\n.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nvoid\nprintHello\n(\nint\nn\n)\n{\n// Base Case\nif\n(\nn\n==\n0\n)\nreturn\n;\ncout\n<<\n\"Hello\"\n<<\nendl\n;\nprintHello\n(\nn\n-\n1\n);\n}\nint\nmain\n()\n{\nprintHello\n(\n5\n);\nreturn\n0\n;\n}\nOutput\nHello\nHello\nHello\nHello\nHello\nThis code demonstrates a simple recursive function that prints the word \"Hello\" five times. The function printHello(n) calls itself with a decremented value of n until it reaches the base case n == 0, at which point the recursion stops. Each recursive call prints \"Hello\" before making the next call, resulting in the message being printed once per call from n = 5 down to n = 1.\nRecursive Function\nA function that calls itself is called a\nrecursive function\n. When a recursive function is called, it executes a set of instructions and then calls itself to execute the same set of instructions with a smaller input. A recursive function should contain,\nRecursive Case\n: Recursive case is the way in which the recursive call is present in the function.\nBase Condition:\nThe base condition is the condition that is used to terminate the recursion.\nC++\nreturntype\nfunction\n(\nparameters\n)\n{\n// base case\nif\n(\nbase\ncondition\n)\n{\nreturn\nbase\nvalue\n;\n}\n// recursive case\nreturn\nrecursive\nexpression\ninvolving\nfunction\n(\nmodified\nparameters\n);\n}\nThis structure allows problems to be broken down into simpler versions of themselves, making recursion a powerful tool for solving problems that can be defined in terms of smaller instances.\nAccording to this, from the first example, we can deduce that:\nBase Condition\nif (n == 0) return;\nRecursive Case\nprintHello(n - 1);\nHow Recursion Works?\nTo understand how recursion works internally, it’s important to see how the\ncall stack\nbehaves during recursive calls. Each time a function calls itself, the current state is saved on the stack, and the new call begins. Once the base case is reached, the function starts returning back, one call at a time.\nThe following example demonstrates both the\ndescending phase\n(going deeper into recursion) and the\nascending phase\n(returning back from recursion):\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nvoid\nf\n(\nint\nn\n)\n{\ncout\n<<\n\"F(\"\n<<\nn\n<<\n\")'s Stack Frame Pushed\n\\n\n\"\n;\nif\n(\nn\n>\n1\n)\n{\nf\n(\nn\n-\n1\n);\nf\n(\nn\n-\n1\n);\n}\ncout\n<<\n\"F(\"\n<<\nn\n<<\n\")'s Stack Frame Removed\n\\n\n\"\n;\n}\nint\nmain\n()\n{\nf\n(\n3\n);\nreturn\n0\n;\n}\nOutput\nF(3)'s Stack Frame Pushed\nF(2)'s Stack Frame Pushed\nF(1)'s Stack Frame Pushed\nF(1)'s Stack Frame Removed\nF(1)'s Stack Frame Pushed\nF(1)'s Stack Frame Removed\nF(2)'s Stack Frame Removed\nF(2)'s Stack Fr...\nIn this program, the function f(int n) prints a message when a new recursive call is made (Stack Frame Pushed) and when it finishes (Stack Frame Removed). This provides a clear view of how stack frames are added and removed during recursion.\nDescending Phase\n: The function keeps calling itself with n - 1 as long as n > 1. This is the phase where the call stack grows. Each call pushes a new stack frame and pauses until its recursive calls complete.\nAscending Phase\n: Once n is no longer greater than 1, the base case is reached, and the function begins to return. As each call completes, its stack frame is removed, and control moves back to the previous call. This unwinding of the stack is the ascending phase.\nFor f(3), the function follows a pattern similar to a binary tree with recursive calls branching left and right. The output shows exactly when each function call begins and ends, helping visualize the stack behavior during recursion.\nIllustrations:\nThis example follows a\ntree recursion\npattern, where each function call makes multiple recursive calls (in this case, two). It’s one of the common forms of recursion. To explore more patterns like\nlinear recursion\n,\ntail recursion\n, and\nindirect recursion\n, check out our detailed article on\nTypes of Recursion.\nMemory Management in Recursion\nLike other functions, the data of a recursive function is stored in stack memory as a stack frame. This stack frame is removed once the function returns a value. In recursion,\nThe function call occurs before returning a value, so the stack frames for each recursive call are placed on top of the existing stack frames in memory.\nOnce the topmost function returns a value, its stack frame is removed, and control is passed back to the function just before it, resuming execution after the point where the recursive call was made.\nThe compiler uses an instruction pointer to keep track of the location to return to after the function execution is complete.\nUnlike iteration, recursion relies on the call stack, making memory management a key differentiator between the two.\nRefer these article to know more about\nFunction Call Stack\n,\nDifference between recursion and iteration\nWhat is Stack Overflow?\nStack overflow is one of the most common errors associated with the recursion which occurs when a function calls itself too many times. As we know that each recursive call requires separate space in the limited stack memory. When there is a large number of recursive calls or recursion goes on infinite times, this stack memory may get exhausted and may not be able to store more data leading to programs' termination.\nApplications of Recursion\nRecursion has many applications in computer science and programming. Here are some of the most common applications of recursion:\nSolving:\nFibonacci sequences, Factorial Function, Reversing an array, Tower of Hanoi.\nBacktracking:\nIt is a technique for solving problems by trying out different solutions and undoing them if they do not work. Recursive algorithms are often used in backtracking.\nSearching and Sorting Algorithms:\nMany searching and sorting algorithms, such as binary search and quicksort, use recursion to divide the problem into smaller sub-problems.\nTree and Graph Traversal:\nRecursive algorithms are often used to traverse trees and graphs, such as depth-first search and breadth-first search.\nMathematical Computations:\nRecursion is also used in many mathematical computations, such as the factorial function and the Fibonacci sequence.\nDynamic Programming:\nIt is a technique for solving optimization problems by breaking them down into smaller sub-problems. Recursive algorithms are often used in dynamic programming.\nOverall, recursion is a powerful and versatile technique that can be used to solve a wide range of problems in programming and computer science.\nDrawbacks of Recursion\nPerformance:\nRecursive algorithms can be less efficient than iterative algorithms in some cases, particularly if the data structure is large or if the recursion goes too deep.\nMemory usage:\nRecursive algorithms can use a lot of memory, particularly if the recursion goes too deep or if the data structure is large. Each recursive call creates a new stack frame on the call stack, which can quickly add up to a significant amount of memory usage.\nCode complexity:\nRecursive algorithms can be more complex than iterative algorithms.\nDebugging:\nRecursive algorithms can be more difficult to debug than iterative algorithms, particularly if the recursion goes too deep or if the program is using multiple recursive calls.\nStack Overflow:\nIf the recursion goes too deep, it can cause a stack overflow error, which can crash the program.\nCreate Quiz\nComment\nN\nnishitjain24\nFollow\n14\nImprove\nN\nnishitjain24\nFollow\n14\nImprove\nArticle Tags :\nRecursion\nC++",
    "content_length": 7627,
    "scraped_at": "2025-12-07 16:24:16",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Inline Functions",
    "url": "https://www.geeksforgeeks.org/cpp/inline-functions-cpp/",
    "content": "An inline function is a function in C++ whose code is expanded at the point of call at compile time. It reduces function-call overhead.\nThe inline keyword suggests replacing a function call with its code to reduce overhead.\nInlining is a request, not guaranteed by the compiler.\nThe compiler may ignore inlining if the function contains loops, recursion, static variables, switch/goto, or a non-void function without a return statement..\nC++\n#include\n<stdio.h>\n// Inline function to calculate sum\ninline\nint\ngetSum\n(\nint\na\n,\nint\nb\n)\n{\nreturn\na\n+\nb\n;\n}\nint\nmain\n()\n{\nint\nnum1\n=\n5\n,\nnum2\n=\n10\n;\n// Call inline function\nint\nresult\n=\ngetSum\n(\nnum1\n,\nnum2\n);\n// Display the result\nprintf\n(\n\"Sum: %d\n\\n\n\"\n,\nresult\n);\nreturn\n0\n;\n}\nOutput\nSum: 15\nNeed for Inline Functions\nFunction calls involve overhead from storing the return address, passing arguments, and returning control, which can be significant for small, frequently used functions.\nInline functions help eliminate this overhead by replacing the function call with the actual code, improving efficiency.\nInline functions are useful only when the function call overhead is higher than the function’s execution time.\nAn example where the inline function has no effect at all:\nC++\n#include\n<stdio.h>\n// Inline function (but compiler may ignore it)\ninline\nvoid\ndisplayMessage\n()\n{\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n5\n;\ni\n++\n)\n{\nprintf\n(\n\"Hello %d\n\\n\n\"\n,\ni\n);\n}\n}\nint\nmain\n()\n{\ndisplayMessage\n();\nreturn\n0\n;\n}\nOutput\nHello 0\nHello 1\nHello 2\nHello 3\nHello 4\nThe function contains a loop, making it large.\nModern compilers may ignore inline for bigger functions.\nThe program works the same whether inline is used or not.\nBehaviour of Inline Functions\nInlined functions have their body replace the call at compile time, so no separate symbol is created.\nInlining is optional; the compiler may choose not to inline the function.\nNon-inlined functions generate a real definition, which can cause multiple-definition errors if used in headers across files.\nC++ allows identical inline functions in multiple files, making them safe for headers, templates, and class definitions.\nInline Functions in Class\nAll the functions defined inside the class are implicitly inline. Thus, all the restrictions of inline functions are also applied here. If you need to explicitly declare an inline function in the class, then just declare the function inside the class and define it outside the class using the inline keyword.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nclass\nA\n{\npublic\n:\n// declare inline\ninline\nint\nsquare\n(\nint\nx\n);\n};\n// Define the function\ninline\nint\nA::square\n(\nint\nx\n)\n{\nreturn\nx\n*\nx\n;\n}\nint\nmain\n()\n{\nA\nobj\n;\ncout\n<<\nobj\n.\nsquare\n(\n3\n);\nreturn\n0\n;\n}\nOutput\n9\nVirtual Functions Inlining\nVirtual functions are resolved at runtime based on the actual object type.\nInlining happens at compile time, where the compiler replaces the function call with its body.\nSince the compiler cannot know which virtual function will be called at compile time, it cannot inline virtual functions.\nIn short, runtime resolution conflicts with compile-time inlining, making inlining of virtual functions impossible.\nI\nnline vs Macros\nIn C++, both inline functions and macros reduce function call overhead for faster execution, but they differ in behavior. Inline functions provide better safety and scoping, while macros are simple preprocessor directives. The table below shows their main differences.\nAspect\nInline Functions\nMacros\nDefinition\nInline functions are functions defined with the\ninline\nkeyword.\nMacros are preprocessor directives defined using.\n#define\n.\nScope\nInline functions have scope and type checking, like regular functions.\nMacros have no scope or type checking. They are replaced by the preprocessor.\nEvaluation of Arguments\nArguments are evaluated once.\nArguments may be evaluated multiple times (e.g., in expressions).\nHandling\nInline functions are handled by the compiler.\nMacros are handled by the preprocessor.\nPrivate Members\nCan access private members of a class.\nCannot access private members of a class.\nExecution Overhead\nCompiler may ignore the\ninline\nrequest if the function is too large.\nMacros are always substituted into code.\nRecursion\nInline functions can call themselves recursively.\nMacros cannot be recursive.\nAdvantages\nFunction call overhead doesn't occur.\nInlining allows the compiler to apply context-specific optimizations not possible with normal function calls.\nSmall inline functions can reduce code size, which is useful in embedded systems.\nDisadvantages\nInlining increases the number of variables and registers used at each call.\nExcessive inlining can enlarge the binary and reduce instruction cache efficiency.\nChanges in an inline function require recompiling all calling locations.\nInline functions may not suit embedded systems where code size is more critical than speed.\nCreate Quiz\nInline Function\nVisit Course\nComment\nK\nkartik\n397\nImprove\nK\nkartik\n397\nImprove\nArticle Tags :\nC++\nCPP-Functions",
    "content_length": 4976,
    "scraped_at": "2025-12-07 16:24:18",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  },
  {
    "title": "Lambda Expression",
    "url": "https://www.geeksforgeeks.org/cpp/lambda-expression-in-c/",
    "content": "C++ 11 introduced\nlambda expressions\nto allow inline functions which can be used for short snippets of code that are not going to be reused. Therefore, they do not require a name. They are mostly used in STL algorithms as callback functions.\nC++\n#include\n<iostream>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\n// Defining a lambda\nauto\nres\n=\n[](\nint\nx\n)\n{\nreturn\nx\n+\nx\n;\n};\n// Using the lambda\ncout\n<<\nres\n(\n5\n);\nreturn\n0\n;\n}\nOutput\n10\nThe lambda expression in the above program takes an integer\nx\nas input and returns the sum of\nx\nwith itself. The result of\nres(5)\nprints\n10\n, as the lambda doubles the value of\n5.\nSyntax\nC++\n[\ncapture\n-\nclause\n]\n(\nparameters\n)\n->\nreturn\n-\ntype\n{\n// definition\n}\nTo learn how to use lambda expressions effectively in your C++ programs, the\nC++ Course\nprovides detailed explanations and examples.\nReturn Type\nGenerally, the\nreturn-type\nin lambda expressions is evaluated by the compiler itself and we don’t need to specify it explicitly. However, in some complex cases e.g. conditional statements, the compiler can’t determine the return type and explicit specification is required.\nParameters\nThese parameters are similar to the function parameters in every way.\nCapture Clause\nA lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from the enclosing scope in three ways using\ncapture clause\n:\n[&]:\ncapture all external variables by reference.\n[=]:\ncapture all external variables by value.\n[a, &b]:\ncapture 'a' by value and 'b' by reference.\nA lambda with an empty capture clause [] can only access variables which are local to it.\nC++\n#include\n<iostream>\n#include\n<vector>\nusing\nnamespace\nstd\n;\nvoid\nprint\n(\nvector\n<\nint\n>\nv\n)\n{\nfor\n(\nauto\nx\n:\nv\n)\ncout\n<<\nx\n<<\n\" \"\n;\ncout\n<<\nendl\n;\n}\nint\nmain\n()\n{\nvector\n<\nint\n>\nv1\n,\nv2\n;\n//  Capture all by reference\nauto\nbyRef\n=\n[\n&\n](\nint\nm\n)\n{\nv1\n.\npush_back\n(\nm\n);\nv2\n.\npush_back\n(\nm\n);\n};\n//  Capture all by value\nauto\nbyVal\n=\n[\n=\n](\nint\nm\n)\nmutable\n{\nv1\n.\npush_back\n(\nm\n);\nv2\n.\npush_back\n(\nm\n);\n};\n//  Capture v1 by reference and v2 by value\nauto\nmixed\n=\n[\n&\nv1\n,\nv2\n](\nint\nm\n)\nmutable\n{\nv1\n.\npush_back\n(\nm\n);\nv2\n.\npush_back\n(\nm\n);\n};\n// Case 1: byRef — modifies both v1 and v2\nbyRef\n(\n20\n);\n// Case 2: byVal — modifies only copies (originals unchanged)\nbyVal\n(\n234\n);\n// Case 3: mixed — modifies only v1 (since v2 is captured by value)\nmixed\n(\n10\n);\nprint\n(\nv1\n);\nprint\n(\nv2\n);\nreturn\n0\n;\n}\nOutput\n20 10 \n20\nLet's understand what happened in this program:\nbyRef\ncaptures all by reference. So pushing\n20\nwill push it into original\nv1\nand\nv2\n.\nbyVal\ncaptures all by value. So pushing\n234\nwill not do anything to original vectors.\nmixed\ncaptures\nv1\nby reference and\nv2\nby value. So pushing\n10\nwill only push it into\nv1.\nThe\nmutable\nkeyword here is used in capture by value lambdas only because, by default, value captured objects are\nconst\n.\nExamples\nLamda expressions are extensively used in STL in place of callback i.e. functions passed as arguments. The below examples demonstrate that:\nSort Vector in Descending Order\nC++\n#include\n<iostream>\n#include\n<vector>\n#include\n<algorithm>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nvector\n<\nint\n>\nv\n=\n{\n5\n,\n1\n,\n8\n,\n3\n,\n9\n,\n2\n};\n// Sort in descending order\nsort\n(\nv\n.\nbegin\n(),\nv\n.\nend\n(),\n[]\n(\nconst\nint\n&\na\n,\nconst\nint\n&\nb\n)\n{\nreturn\na\n>\nb\n;\n});\nfor\n(\nint\nx\n:\nv\n)\ncout\n<<\nx\n<<\n\" \"\n;\nreturn\n0\n;\n}\nOutput\n9 8 5 3 2 1\nFind First Number Divisible by 3\nCPP\n#include\n<iostream>\n#include\n<vector>\n#include\n<algorithm>\nusing\nnamespace\nstd\n;\nint\nmain\n()\n{\nvector\n<\nint\n>\nv\n=\n{\n5\n,\n1\n,\n8\n,\n3\n,\n9\n,\n2\n};\n// Sort in descending order\nauto\nit\n=\nfind_if\n(\nv\n.\nbegin\n(),\nv\n.\nend\n(),\n[]\n(\nconst\nint\n&\na\n)\n{\nreturn\na\n%\n3\n==\n0\n;\n});\nif\n(\nit\n!=\nv\n.\nend\n())\ncout\n<<\n*\nit\n;\nelse\ncout\n<<\n\"No such element\"\n;\nreturn\n0\n;\n}\nOutput\n3\nApplications\nLambda expressions' main purpose was to replace the functions in callbacks by providing inline definitions. Following are the common applications of lambda expressions in C++\nInline, Anonymous Functions\n: Write small functions directly where needed without naming them.\nSTL Algorithms\n: Pass custom comparison or transformation logic to algorithms like sort, for_each, etc.\nCallbacks and Event Handling\n: Use lambdas as callbacks for asynchronous operations or event handlers.\nThreading and Concurrency\n: Pass lambdas to threads for quick, inline tasks without defining separate functions.\nCustom Comparators in Containers\n: Use lambdas as comparators for containers like priority_queue, set, etc.\nCreate Quiz\nLamda Expressions in C++\nVisit Course\nComment\nK\nkartik\n187\nImprove\nK\nkartik\n187\nImprove\nArticle Tags :\nC++\ncpp-advanced",
    "content_length": 4659,
    "scraped_at": "2025-12-07 16:24:20",
    "source": "GeeksforGeeks",
    "course": "Programming Fundamentals",
    "language": "C++"
  }
]